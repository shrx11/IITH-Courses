(* DEMO Lexer file in OCamllex for Tureasy *)
(* Using another file as tokem type generated by Parser is not currently available*)

{
    (*open Parser*)
    open Printf      (* error reporting *)
    open Lexing

    let linecounter = ref 1

    type token = 
    | LBRACE
    | RBRACE 
    | LPAREN
    | RPAREN 
    | LBRACK 
    | RBRACK
    | SEMICOLON
    | DOT
    | COLON
    | COMMA
    | TAG_BEGIN of string 
    | TAG_END of string
    | UNEG 
    | INCR
    | DECR
    | LSHIFT
    | RSHIFT
    | EXPONENT
    | MODULO
    | MULTIPLY
    | DIVIDE
    | PLUS
    | MINUS
    | UNION
    | INTERSECT
    | SETDIFF 
    | GT
    | GTE
    | LT
    | LTE
    | EQUAL
    | NOT_EQUAL
    | AND
    | OR
    | ASSIGN
    | MULT_ASSIGN
    | DIV_ASSIGN
    | PLUS_ASSIGN
    | MINUS_ASSIGN
    | EXP_ASSIGN
    | MOD_ASSIGN
    | VOID
    | BOOL
    | INT
    | FLOAT
    | STRING 
    | MATRIX
    | GRAPH
    | NUMSET 
    | STRSET 
    | STRUCT
    | LINK 
    | IF
    | ELSE 
    | LOOP
    | BREAK
    | CONTINUE 
    | RETURN 
    | CASE 
    | DEFAULT
    | CONST 
    | TRUE
    | FALSE 
    | NULL 
    | INT_L of int
    | FLOAT_L of float
    | STRING_L of string
    | ID of string
    
    exception EOF

    exception SyntaxError of string
    
    let error character message lnum = 
    sprintf "\nline %d: %s : %s" lnum character message
    
    let syntax_error lexbuf message lnum = 
    raise ( SyntaxError(error (lexeme lexbuf) (message) (lnum)) )

}

let letter  = ['A'-'Z' 'a'-'z']
let digit = ['0'-'9']

rule token = parse
  [' ' '\t' '\r']                      { token lexbuf }        (* whitespace *)
| ['\n']                               { incr linecounter ; token lexbuf }
| "$*"                                 { ml_comment lexbuf }   (* multi-line comments *)  
| "$"                                  { sl_comment lexbuf }   (* single-line comments *) 
(*                   Syntax                  *)
| '{'                                  { LBRACE }
| '}'                                  { RBRACE }
| '('                                  { LPAREN }
| ')'                                  { RPAREN }
| '['                                  { LBRACK }
| ']'                                  { RBRACK }
| ';'                                  { SEMICOLON }
| '.'                                  { DOT }
| ':'                                  { COLON }
| ','                                  { COMMA }
| "#" (letter(letter|digit)* as tag)   { TAG_BEGIN(tag) } 
| "#!" (letter(letter|digit)* as tag)  { TAG_END(tag)   }   
(*                 Operators                 *)
| '!'                                  { UNEG      }
| "++"                                 { INCR      }
| "--"                                 { DECR      }
| "<<"                                 { LSHIFT    }
| ">>"                                 { RSHIFT    }
| '^'                                  { EXPONENT  }
| '%'                                  { MODULO    }
| '*'                                  { MULTIPLY  }
| '/'                                  { DIVIDE    }
| '+'                                  { PLUS      }
| '-'                                  { MINUS     } 
| '|'                                  { UNION     }
| '&'                                  { INTERSECT }
| '~'                                  { SETDIFF   }
| '>'                                  { GT        }
| ">="                                 { GTE       }
| '<'                                  { LT        }
| "<="                                 { LTE       }
| "=="                                 { EQUAL     }
| "!="                                 { NOT_EQUAL }
| "AND"                                { AND       }
| "OR"                                 { OR        }
| '='                                  { ASSIGN    }
(*                 Datatypes                 *)
| "void"                               { VOID      }
| "bool"                               { BOOL      }
| "int"                                { INT       }
| "float"                              { FLOAT     }
| "string"                             { STRING    }
| "matrix"                             { MATRIX    }
| "graph"                              { GRAPH     }
| "numset"                             { NUMSET    }
| "strset"                             { STRSET    }
| "struct"                             { STRUCT    }
(*                 Keywords                  *)
| "link"                               { LINK      }
| "if"                                 { IF        }
| "else"                               { ELSE      }
| "loop"                               { LOOP      }
| "break"                              { BREAK     }
| "continue"                           { CONTINUE  }
| "return"                             { RETURN    }
| "case"                               { CASE      }
| "default"                            { DEFAULT   }
| "const"                              { CONST     }
(*                 Literals                  *)
| "true"                               { TRUE      }
| "false"                              { FALSE     }
| "NULL"                               { NULL      }
| ['-']?digit+ as lxm                  { INT_L(int_of_string lxm)}
| ['-']?digit+['.']digit+ as lxm       { FLOAT_L(float_of_string lxm)}
| '"' (([^ '"'] | "\\\"")* as lxm) '"' { STRING_L(lxm) }
| ['a'-'z' 'A'-'Z']['a'-'z' 'A'-'Z' '0'-'9' '_']*  as lxm { ID(lxm) }
| ['0'-'9' '_']['a'-'z' 'A'-'Z' '0'-'9' '_']*      as lxm { syntax_error (lexbuf) ("Invalid identifier name " ^ lxm) (!linecounter) }
| eof                                  { raise EOF }
(* Raising error for unidentified character*)
| _                                    { syntax_error (lexbuf) ("Unexpected character detected") (!linecounter) }  

and ml_comment = parse
  "*$"                                 { token lexbuf }
| "\n"                                 { incr linecounter ; ml_comment lexbuf }
| eof                                  { syntax_error (lexbuf) ("Expected '*$' before EOF") (!linecounter) }  
| _                                    { ml_comment lexbuf }

and sl_comment = parse
  "\n"                                 { incr linecounter ; token lexbuf }
| eof                                  { raise EOF }
| _                                    { sl_comment lexbuf }


{
    let main () = begin
      try 
        (*let lexbuf = from_channel stdin in*)
        let fileName = Sys.argv.(1) in
        let handler = open_in fileName in 
        let lexbuf = from_channel handler in
        while true do 
          let inp_token = token lexbuf in 
          match inp_token with 
          | LBRACE -> printf "LBRACE "
          | RBRACE -> printf "RBRACE "
          | LPAREN -> printf "LPAREN "
          | RPAREN -> printf "RPAREN "
          | LBRACK -> printf "LBRACK "
          | RBRACK -> printf "RBRACK "
          | SEMICOLON -> printf "SEMICOLON "
          | DOT    -> printf "DOT "
          | COLON  -> printf "COLON "
          | COMMA  -> printf "COMMA "
          | TAG_BEGIN(str) -> printf "TAG_BEGIN: %s  " str
          | TAG_END(str)   -> printf "TAG_END: %s   " str
          (*                 Operators                 *)
          |  UNEG     -> printf "UNEG "
          |  INCR     -> printf "INCR "
          |  DECR     -> printf "DECR "
          |  LSHIFT   -> printf "LSHIFT "
          |  RSHIFT   -> printf "RSHIFT "
          |  EXPONENT -> printf "EXPONENT "
          |  MODULO   -> printf "MODULO "
          |  MULTIPLY -> printf "MULTIPLY "
          |  DIVIDE   -> printf "DIVIDE "
          |  PLUS     -> printf "PLUS "
          |  MINUS    -> printf "MINUS "
          |  UNION    -> printf "UNION "
          |  INTERSECT-> printf "INTERSECT "
          |  SETDIFF  -> printf "SETDIFF "
          |  GT       -> printf "GT "
          |  GTE      -> printf "GTE "
          |  LT       -> printf "LT "
          |  LTE      -> printf "LTE "
          |  EQUAL    -> printf "EQUAL "
          |  NOT_EQUAL-> printf "NOT_EQUAL "
          |  AND      -> printf "AND "
          |  OR       -> printf "OR "
          |  ASSIGN   -> printf "ASSIGN "
          |  MULT_ASSIGN  -> printf "MULT_ASSIGN "
          |  DIV_ASSIGN   -> printf "DIV_ASSIGN "
          |  PLUS_ASSIGN  -> printf "PLUS_ASSIGN "
          |  MINUS_ASSIGN -> printf "MINUS_ASSIGN "
          |  EXP_ASSIGN   -> printf "EXP_ASSIGN "
          |  MOD_ASSIGN   -> printf "MOD_ASSIGN "
          (*                 Datatypes                 *)
          |  VOID      -> printf "VOID "
          |  BOOL      -> printf "BOOL "
          |  INT       -> printf "INT "
          |  FLOAT     -> printf "FLOAT "
          |  STRING    -> printf "STRING "
          |  MATRIX    -> printf "MATRIX "
          |  GRAPH     -> printf "GRAPH "
          |  NUMSET    -> printf "NUMSET "
          |  STRSET    -> printf "STRSET "
          |  STRUCT    -> printf "STRUCT "
          (*                 Keywords                  *)
          |  LINK      -> printf "LINK "
          |  IF        -> printf "IF "
          |  ELSE      -> printf "ELSE "
          |  LOOP      -> printf "LOOP "
          |  BREAK     -> printf "BREAK "
          |  CONTINUE  -> printf "CONTINUE "
          |  RETURN    -> printf "RETURN "
          |  CASE      -> printf "CASE "
          |  DEFAULT   -> printf "DEFAULT "
          |  CONST     -> printf "CONST "
          (*                  Literals                 *)
          |  TRUE      -> printf "TRUE "
          |  FALSE     -> printf "FALSE "
          |  NULL      -> printf "NULL "
          |  INT_L(x)     -> printf "INTEGER:%d " x
          |  FLOAT_L(x)   -> printf "FLOAT:%f " x
          |  STRING_L(x)  -> printf "STRING:%s " x
          |  ID(x)        -> printf "IDENTIFIER:%s " x 
        done
      with EOF -> printf "\n"; exit 0
    end ;;
    main () ;;
}
